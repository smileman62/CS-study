/**
 * 코딩테스트연습 > 연습문제 > 숫자야구
 * 
 * 문제를 푼 날짜:
 * 2025년 11월 09일
 * 
 * 문제 설명:
 * 당신은 숫자 야구를 플레이하는 프로그램을 작성해야 합니다.
 * 숫자 야구란 1 ~ 9 사이의 서로 다른 숫자 4개로 이루어진 비밀번호를 맞히는 게임입니다.
 * 당신은 1000 이상 9999 이하의 정수를 제출할 수 있는 기회가 총 n번 있으며, 수를 제출할 때마다 비밀번호에 관한 단서가 주어집니다. 이때 제출한 수의 각 자릿수에 대해 아래와 같이 판정합니다.
 * 숫자가 비밀번호에 포함되어 있지 않다면 : OUT
 * 숫자가 비밀번호에 포함되어 있지만, 위치가 틀렸다면 : BALL
 * 숫자가 비밀번호에 포함되어 있고, 위치까지 정확하다면 : STRIKE
 * 위와 같이 STRIKE, BALL으로 판정한 숫자의 개수를 세어, STRIKE가 x개 / BALL이 y개라면 "xS yB" 형식으로 단서가 주어집니다.
 * 
 * 아래 표는 비밀번호가 1357일 때 제출한 수에 따른 단서의 예시입니다
 * 
 * 제출	단서	설명
 * 7000	"0S 1B"	7이 비밀번호에 포함되어 있지만 위치가 틀렸으므로 1 BALL입니다.
 * 2244	"0S 0B"	-
 * 3333	"1S 3B"	3이 비밀번호에 포함되어 있습니다. 위치가 정확한 3이 1개, 위치가 틀린 3이 3개 있으므로 1 STRIKE, 3 BALL 입니다.
 * 3457	"2S 1B"	3, 5, 7이 비밀번호에 포함되어 있습니다. 5, 7은 위치가 정확합니다. 따라서 2 STRIKE, 1 BALL 입니다.
 * 7531	"0S 4B"	7, 5, 3, 1이 비밀번호에 포함되어 있지만 네 숫자 모두 위치가 틀렸으므로 4 BALL 입니다.
 * 1357	"4S 0B"	1, 3, 5, 7이 비밀번호에 포함되어 있고, 네 숫자 모두 위치가 정확하므로 4 STRIKE 입니다.
 * 숫자 야구의 최대 제출 횟수를 나타내는 정수 n과, 수를 제출하기 위한 submit 함수가 주어집니다. submit 함수를 호출해 비밀번호를 알아내, 숫자 야구의 비밀번호를 return 하도록 solution 함수를 완성해 주세요.
 * 
 * 정답 판정을 받으려면 submit 함수를 호출한 횟수가 n을 초과하지 않아야 하며, 올바른 비밀번호를 return 해야 합니다.
 * 
 * 제한사항
 * 6 ≤ n ≤ 3,024
 * submit 함수는 1000 이상 9999 이하의 정수를 전달받아, 단서를 "xS yB" 형식의 문자열로 return 합니다.
 * 1000 ~ 9999 사이의 정수가 아닌 값을 전달하는 경우 오답으로 판정합니다.
 * submit 함수 사용 예시가 초기 코드로 주어집니다. 해당 코드는 1000 ~ 9999를 순서대로 제출해, 단서가 "4S 0B"인 경우 해당 정수를 return 하는 코드입니다.
 * 테스트 케이스 구성 안내
 * 아래는 테스트 케이스 구성을 나타냅니다. 각 그룹 내의 테스트 케이스를 모두 통과하면 해당 그룹에 할당된 점수를 획득할 수 있습니다.
 * 
 * 그룹	총점	추가 제한 사항
 * #1	10%	n = 3024
 * #2	40%	n = 33
 * #3	25%	n = 14
 * #4	15%	n = 9
 * #5	10%	n = 6
 * 
 * 입출력 예
 * n	result
 * 3024	1357
 * 3024	3986
 * 33	7685
 * 
 * 예시로 주어지는 테스트 케이스는 비밀번호가 고정되어 있습니다.
 * 채점 테스트 케이스
 * 정답 판정을 받은 채점 테스트 케이스에 따라, 정해진 점수를 획득할 수 있습니다.
 * 채점 테스트케이스 일부는 비밀번호가 고정되어 있습니다.
 * 채점 테스트케이스 일부는 solution 함수가 submit을 호출할 때마다 비밀번호가 바뀝니다. (단, 바뀐 비밀번호가 이전에 주어진 단서와 모순되는 경우는 없습니다.)
 * 입출력 예 설명
 * 
 * 입출력 예 #1
 * 비밀번호는 1357입니다. submit 함수를 3024번 이하로 호출하고 1357을 return 해야 합니다.
 * 
 * 입출력 예 #2
 * 비밀번호는 3986입니다. submit 함수를 3024번 이하로 호출하고 3986을 return 해야 합니다.
 * 
 * 입출력 예 #3
 * 비밀번호는 7685입니다. submit 함수를 33번 이하로 호출하고 7685를 return 해야 합니다.
 * 
 * 문제 풀이 및 후기:
 * 먼저, 어떤 식으로 후보군을 추려나갈지에 대한 고민을 조금 했었는데,
 * 처음에는 임의의 수를 submit에 넣어 결과를 통해 정답인 수를 유추하는 방법으로 숫자를 찾으려 했었다.
 * 
 * 하지만 그건 너무 구현이 어려울 것 같아서 다른 수를 생각해봤다.
 * 
 * 1000 ~ 9999 까지의 수 중에서 중복된 숫자가 없고 0이 포함되지 않은 수들을 모두 후보군으로 설정하여, candiates 배열에 넣었다.
 * 그 후, candidates 배열의 마지막 수를 submit에 넣어 결과를 받아오고, 그 결과와 isCompatible 함수를 통해 맞지 않는 후보군들을 걸러내는 방법을 사용했다.
 * 
 * 만약 "0S 0B"이 아닌 다른 결과가 나왔다만, 후보군 안의 숫자는 최소 하나 이상 무조건 정답에 포함되어 있기 때문에,
 * includes 메소드를 활용하여 그 숫자를 포함한 후보군을 걸러내는 방법이었다.
 * 
 * includes 메소드를 활용하여 후보군을 걸러내는 방법이 조금 신선했던 것 같다. (아주 편안하고 좋다 ㅎㅎ)
 * 그리고 이런 정답을 찾는 문제에서, 마치 사람이 추론하는 것처럼 임의의 정답을 집어 넣어서 나온 힌트를 통해 답을 추리해나가는 방식 보다는,
 * 한 배열에 가능한 후보군을 모두 집어넣고 (candidates 처럼), 순차적으로 그 배열 안에서 후보군을 좁혀나가는 방법으로 접근해야 하는 것을 깨달았다.
 * 
 * 
*/

function solution(n, submit) {
    // 1. 가능한 모든 후보(1000~9999, 중복 없는 4자리, 0 제외) 생성
    let candidates = [];
    for (let num = 1000; num <= 9999; num++) {
        const s = String(num);
        if (!isUnique(s) && !s.includes("0")) {
        candidates.push(s);
        }
    }
        
    function isUnique(str) {
        for (let i = 0; i < 4; i++) {
            if (str.indexOf(str[i]) !== str.lastIndexOf(str[i])) {
                return true;
            } else {
                return false;
            }
        }
    }

    // 2. 두 숫자를 비교해 "xS yB"를 계산하는 함수
    function getHint(secret, guess) {
        let strike = 0;
        let ball = 0;
        for (let i = 0; i < 4; i++) {
        if (secret[i] === guess[i]) strike++;
        else if (secret.includes(guess[i])) ball++;
        }
        return `${strike}S ${ball}B`;
    }

    // 3. 후보 검증 함수
    function isCompatible(guess, candidate, result) {
        return getHint(candidate, guess) === result;
    }
        
    let count = 0;
        
    // 4. submit()을 호출하며 후보를 점점 줄이기
    while (candidates.length > 0) {
        const guess = candidates[candidates.length - 1];
        const result = submit(Number(guess)); // 예: "1S 2B"
        
        count += 1
        console.log(count)

        if (result === "4S 0B") {
            console.log(guess)
            
            return Number(guess)
        }; // 정답 찾음

        // 단서와 일치하는 후보만 남김
        candidates = candidates.filter((c) => isCompatible(guess, c, result));

        // n번까지만 작동
        if (n-- <= 0) break;
    }
    
  return -1;
}