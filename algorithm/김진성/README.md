# 버블정렬 (Bubble sort) 

### 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.

첫 번째 자료와 두 번째 자료, 두번째 자료와 세 번째 자료를... (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.

1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로, 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외도고, 2회전을 수행하고 나면 끝에서 두 번쨰 자료까지는 정렬에서 제외된다.

이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

### 버블정렬 (Bubble sort) 알고리즘의 예제
![alt](https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png)

### 버블정렬 (bubble sort) 알고리즘의 특징
장점
- 구현이 매우 간단하다.

단점
- 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야한다.
- 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.

일반적으로 자료의 교환작업(swap)이 자료의 이동작업(move)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 **쓰이지 않는다.**

### 버블 정렬(bubble sort)의 시간복잡도

비교 횟수
- 최상, 평균, 최악 모두 일정
- n-1, n-2, … , 2, 1 번 = n(n-1)/2

교환 횟수
- 입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 (비교 횟수 * 3) 번 = 3n(n-1)/2
- 입력 자료가 이미 정렬되어 있는 최상의 경우, 자료의 이동이 발생하지 않는다.

T(n) = O(n^2)

---

# 선택정렬 (selection sort) 

### 제자리 정렬(in-place sorting) 알고리즘 중 하나
입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법

해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
- 첫 번째 순서에는 첫 번쨰 위치에 가장 최솟값을 넣는다.
- 두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.

### 선택 정렬(selection sort) 알고리즘의 구체적인 개념
- 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.
- **1회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로** 그 다음 회전에서는 두 번째 자료를 가지고 비교한다. 마찬가지로 3회전에서는 세 번째 자료를 정렬한다.

### 선택정렬 (selection sort) 알고리즘의 예제
![alt](https://gmlwjd9405.github.io/images/algorithm-selection-sort/selection-sort.png)

### 선택정렬 (selection sort) 알고리즘의 특징
장점
- 자료 이동 횟수가 미리 결정된다.

단점
- 안정성을 만족하지 않는다.
- 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.

### 선택정렬 (selection sort) 시간복잡도

**비교 횟수**
- 두 개의 for 루프의 실행 횟수
- 외부 루프: (n-1)번
- 내부 루프(최솟값 찾기): n-1, n-2, … , 2, 1 번

**교환 횟수**
- 외부 루프의 실행 횟수와 동일. 즉, 상수 시간 작업
- 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 3(n-1)번

T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = **O(n^2)**